#!/usr/bin/env node
//#region IMPORTS
const chalk = require('chalk');
const clear = require('clear');
const figlet = require('figlet');
const fs = require('fs');
const YAML = require('js-yaml');
//#endregion

const ROOT = '.';
const FILTER = '.c2e.yaml';
const GROUPING = ['capability', 'storyboard', 'scene', 'user story'];
const ACTIONS = ['actions'];
const EVALUATIONS = ['criteria'];

// MAIN
printBanner();
processFiles();
fs.watch(ROOT, (event, fileName) => {
    try {
        if (fileName) {
            console.log(`${fileName} file Changed`);
            saveOutputFile(loadInputFile(fileName));
        }
    }
    catch (err) {
        console.log(chalk.bold.italic.redBright(err.message));
    }
});

//#region FUNCTIONS
function printBanner() {
    clear();
    console.log(
        chalk.greenBright(figlet.textSync('C -2-> E', { font: "ANSI Shadow", })),
        chalk.bold.italic.gray(' by the Modly community v0.0.1')
    );
    console.log(chalk.green('C2E generates Mocha/Chai *.spec.js test files from *.c2e.json files located in the local folder.'));
    console.log(chalk.bold.redBright('ðŸš¨ WARNING: C2E currently overwrites *.spec.js files without warning! ðŸš¨ '));
};
function processFiles() {
    fs
        .readdirSync(ROOT)
        .filter(fileName => { return fileName.includes(FILTER) })
        .map(fileName => {
            saveOutputFile(loadInputFile(fileName));
        });
};
function loadInputFile(fileName) {
    console.log('Processing => ', fileName);
    return YAML.load(fs.readFileSync(fileName, 'utf8'));
};
function saveOutputFile(inputFileContent) {
    global.outputImports = "";
    if (!fs.existsSync("./" + Object.keys(inputFileContent)[1])) { fs.mkdirSync("./" + Object.keys(inputFileContent)[1]); };
    let outputFileName = "v" + inputFileContent.version + " - " + Object.keys(inputFileContent)[1] + " - " + Object.keys(Object.values(inputFileContent)[1])[2];
    let outputContentHeader = '// Test file generated by C2E https://community.modlycrew/c2e\n'
    let outputContentGenerated = generateOutput(inputFileContent);
    let outputContentImports = '// Imports\n' + outputImports + '\n';
    let outputContentAjv = ajvHelpers();
    fs.writeFileSync("./" + Object.keys(inputFileContent)[1] + "/" + outputFileName + '.spec.js', outputContentHeader + outputContentImports + outputContentGenerated + outputContentAjv);
    console.log('Writing => ', "./" + Object.keys(inputFileContent)[1] + "/" + outputFileName + '.spec.js');
}
function generateOutput(input, output = "") {
    let array = Object.entries(input)
        .filter(([filterKey, filterValue]) => (
            filterKey[0] != 'type' &&
            filterKey[0] != 'description' &&
            filterKey[0] != 'version'
        ) && (
                typeof filterValue === 'object'
            )
        ).map(([key, value]) => {
            if (GROUPING.includes(value.type)) {
                output += '\n';
                output += "describe('" + {
                    "capability": "ðŸ¢ [" + input.version + "] ",
                    "storyboard": "ðŸ“‘",
                    "scene": "ðŸ“ƒ",
                    "user story": "ðŸ‘©â€ðŸ­",
                }[value.type] + key.replace('\'', '"') + " - " + value.description.replace(/'/g, "\"") + "',()=>{" + generateOutput(value) + '});'
            };
            if (ACTIONS.includes(value.type)) {
                let outputVariables = "";
                let outputIt = "it('ðŸ”§ " + key + "',()=>{\n";
                let outputBody = "";
                Object.entries(value).filter(([filterKey, filterValue]) => (filterKey != 'type')).map(([actionKey, actionValue]) => {
                    actionValue = actionValue.replace(/\/\/|!|js?\r?\n|\r/g, "");
                    const actionVariable = actionValue.split('\n')[0].split(' =')[0];
                    if (actionValue.split('\n')[0].split(' ')[0] === 'import') {
                        outputImports += actionValue.substring(0, actionValue.lastIndexOf(";")) + ';\n';
                    } else {
                        if (actionValue.includes(" = await ")) {
                            outputBody += "cy.log('" + actionKey.replace(/'/g, "\"") + "');\n";
                            actionValue = actionValue.substring(0, actionValue.lastIndexOf(";")) + '\n';
                            outputBody += 'cy.wrap(null).then(() => {\n';
                            outputBody += '    return (new Cypress.Promise((resolve, reject) => {\n';
                            outputBody += '        resolve(\n';
                            outputBody += '            ' + actionValue.split(' = await ')[1];
                            outputBody += '        );';
                            outputBody += '    })).then((obj) => {\n';
                            outputBody += '        ' + actionVariable + ' = obj;\n';
                            outputBody += '        cy.log("' + actionVariable + ' => " + JSON.stringify(' + actionVariable + '));\n';
                            outputBody += '    });\n';
                            outputBody += '});\n';
                        } else {
                            outputBody += actionValue;
                            outputBody += "cy.log('" + actionVariable + " = ', JSON.stringify(" + actionVariable + "));\n";
                        };
                        outputVariables += 'let ' + actionVariable + ';\n';
                    };
                });
                output += outputVariables + outputIt + outputBody + '});'
            };
            if (EVALUATIONS.includes(value.type)) {
                output += '\n' + 'it("ðŸš§ ' + key.replace(/'/g, "\"") + '",()=>{' + generateCriteria(value) + '});';
            };
        });
    return output;
    function generateCriteria(value) {
        let expectOutput = "";
        Object.entries(value.expectations).map(([expectationKey, expectationCode]) => {
            expectationCode = expectationCode ? expectationCode.replace(/\/\/|!|js?\r?\n|\r/g, "") : "";
            expectOutput += expectationCode.replace(').', ',"' + expectationKey + '").');
        });
        return expectOutput;
    }
}
function ajvHelpers() {
    let ajvOutput = '\n\n// AJV Object Validation Methods\n';
    ajvOutput += 'import Ajv from "ajv";\n';
    ajvOutput += 'const ajv = new Ajv({ $data: true, allErrors: true, allowMatchingProperties: true, });\n';
    ajvOutput += 'require("ajv-formats")(ajv);\n';
    ajvOutput += 'require("ajv-merge-patch")(ajv);\n';
    ajvOutput += 'ajv.addKeyword("$version");\n';
    ajvOutput += 'function validateObject(objectToValidate, schema) {\n';
    ajvOutput += '    expect(objectToValidate, "Schema => " + JSON.stringify(schema)).to.equal(ajv.validate(schema.$id, objectToValidate) ? objectToValidate : ajv.errors.filter(e => e.keyword != "$merge"));\n';
    ajvOutput += '}\n';
    return ajvOutput;
}
//#endregion
