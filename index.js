#!/usr/bin/env node
//#region IMPORTS
const chalk = require('chalk');
const clear = require('clear');
const figlet = require('figlet');
const fs = require('fs');
//#endregion

const ROOT = '.';
const FILTER = '.c2e.json';
const GROUPING = ['Capability', 'Storyboard', 'Scene', 'User Story'];
const ACTIONS = ['Action'];
const EVALUATIONS = ['Criteria'];

// MAIN
printBanner();
processFiles();

//#region FUNCTIONS
function printBanner() {
    clear();
    console.log(
        chalk.greenBright(figlet.textSync('C -2-> E', { font: "ANSI Shadow", })),
        chalk.bold.italic.gray(' by the Modly community v0.0.1')
    );
    console.log(chalk.green('C2E generates Mocha/Chai *.spec.js test files from *.c2e.json files located in the local folder.'));
    console.log(chalk.bold.redBright('🚨 WARNING: C2E currently overwrites *.spec.js files without warning! 🚨 '));
};
function processFiles() {
    fs
        .readdirSync(ROOT)
        .filter(fileName => { return fileName.includes(FILTER) })
        .map(fileName => {
            saveOutputFile(loadInputFile(fileName));
        });
};
function loadInputFile(fileName) {
    console.log('Processing => ', fileName);
    return JSON.parse(fs.readFileSync(fileName, 'utf8'));
};
function saveOutputFile(inputFileContent) {
    if (!fs.existsSync("./" + Object.keys(inputFileContent)[1])) { fs.mkdirSync("./" + Object.keys(inputFileContent)[1]); };
    let outputFileName = "v" + inputFileContent['_version'] + " " + Object.keys(inputFileContent)[1] + " - " + Object.keys(Object.values(inputFileContent)[1])[2];
    let outputFileContent = '// Test file generated by C2E https://community.modlycrew/c2e \n' + generateOutput(inputFileContent);
    fs.writeFileSync("./" + Object.keys(inputFileContent)[1] + "/" + outputFileName + '.spec.js', outputFileContent);
    console.log('Writing => ', "./" + Object.keys(inputFileContent)[1] + "/" + outputFileName + '.spec.js');
}
function generateOutput(input, output = "") {
    let array = Object.entries(input)
        .filter(([filterKey, filterValue]) => (filterKey[0] != '_type' && filterKey[0] != '_description' && filterKey[0] != '_version') && (typeof filterValue === 'object'))
        .map(([key, value]) => {
            output += '\n';
            if (GROUPING.includes(value._type)) {
                output += "describe('" + {
                    "Capability": "🏢 [" + input['_version'] + "] ",
                    "Storyboard": "📑",
                    "Scene": "📃",
                    "User Story": "👩‍🏭",
                }[value._type] + key + " - " + value._description.replace(/'/g, "\"") + "',()=>{" + generateOutput(value) + '\n});'
            };
            if (ACTIONS.includes(value._type)) {
                let outputIt = "it('🔧 " + key + " - " + value._description.replace(/'/g, "\"") + "',()=>{";
                let outputLetVariables = "";
                let outputBody = "";
                Object.entries(value).filter(([filterKey, filterValue]) => (filterKey[0][0] != '_')).map(([actionKey, actionValue]) => {
                    outputLetVariables += "let " + actionKey + ";\n";
                    outputBody += actionKey + " = " + actionValue + ";\n";
                    outputBody += "cy.log('" + actionKey + " set to ' ," + actionKey + ")";
                });
                output += outputLetVariables + outputIt + outputBody + '\n});'
            };
            if (EVALUATIONS.includes(value._type)) {
                output += 'it("🚧 ' + key + ' - Given ' + value.Given.replace(/'/g, "\"") + ', when ' + value.When.replace(/'/g, "\"") + ' then...",()=>{' + generateCriteria(value) + '});';
            };
        });
    return output;
    function generateCriteria(value) {
        let expectOutput = "";
        Object.entries(value.Then).map(([expectationKey, expectationCode]) => {
            if (expectationCode._expect && Object.keys(expectationCode)[2]) {
                expectOutput += 'expect(' + expectationCode._expect + ',"' + expectationKey + '").' + {
                    'to equal': 'to.equal(',
                    'to be a type of': "to.be.a(",
                    'to be the same type as': 'to.be.a(typeof ',
                    'to be below': "to.be.below(",
                    'to be above': "to.be.above(",
                    'to have': "to.include.all.keys(",
                    'to not have': "to.include.all.keys(",
                }[Object.keys(expectationCode)[2]] + Object.values(expectationCode)[2] + ');\n';
            };
        });
        return expectOutput;
    }
}
//#endregion

//#region AJV Helpers (see roadmap)
import Ajv from "ajv";
export function loadAjv() {
    const ajv = new Ajv({
        $data: true,
        allErrors: true,
        allowMatchingProperties: true,
    });
    require('ajv-formats')(ajv);
    require('ajv-merge-patch')(ajv);
    ajv.addKeyword("$version");
    //add ajv-keywords if needing more complex tests ref https://github.com/ajv-validator/ajv-keywords#keywords
    return ajv;
}
export function validateObject(objectToValidate, schema, ajvObject) {
    expect(objectToValidate, 'Schema => ' + JSON.stringify(schema)).to.equal(ajvObject.validate(schema.$id, objectToValidate) ? objectToValidate : ajvObject.errors.filter(e => e.keyword != '$merge'));
}
//#endregion
